# StudBot - chatbot dedykowany studentom
# Główna dokumentacja projektu



![86bfd1ba-c53b-4ba0-b074-6606362f6240](https://github.com/KSchlagowski/SoftwareEngineeringChatbot/blob/master/StudBot%20_Dokumentacja/studbot.webp)
![Licencja wykorzystania Llama3.2:3b](https://github.com/KSchlagowski/SoftwareEngineeringChatbot/blob/master/StudBot%20_Dokumentacja/LICENSE%20AGREEMENT%20llama.md)
![Licencja wykorzystania All-minilm](https://github.com/KSchlagowski/SoftwareEngineeringChatbot/blob/master/StudBot%20_Dokumentacja/LICENSE%20AGREEMENT%20all-minilm.txt)

Projekt autorstwa:

- Kamil Schlagowski 269402
- Kacper Budniak 23509

------



# 1. Opis problemu

Wielu studentów mierzy się z problemem jakim jest chaos organizacyjny w zarządzaniu nauką i trudności w zrozumieniu wymagań akademickich. Programy studiów często są rozbudowane, a zarazem wszystkie wyglądają bardzo podobnie. Wachlarz przedmiotów na każdym semestrze wiąże się z dużą różnorodnością form zaliczeń. Wielu studentów zmaga się z nadmiarem informacji, które często napisane są w złożonym i formalnym języku. To sprawia, że trudniej jest jasno określić cele kursu, priorytety działań oraz sposób przygotowania do egzaminów czy zaliczeń. Jednocześnie studenci muszą samodzielnie planować czas nauki, uwzględniając zarówno swoje możliwości, jak i liczne terminy i obowiązki. Często prowadzi to do nieefektywnego zarządzania czasem, braku przygotowania do kluczowych wydarzeń akademickich i zwiększonego stresu. W takim środowisku, gdzie presja czasu i wymagania są ogromne, łatwo o zaniedbanie ważnych elementów nauki lub nadmierne skupienie się na mniej istotnych aspektach.

# 2. Cel projektu

Studbot, jako inteligentny asystent edukacyjny, eliminuje te problemy. Analizując szczegółowo karty przedmiotów, przekształca skomplikowane informacje w proste i zrozumiałe rekomendacje. Pomaga w stworzeniu spersonalizowanego harmonogramu nauki, wskazuje kluczowe zagadnienia, literaturę przedmiotu i sposób zaliczenia Dzięki temu studenci mogą skupić się na efektywnym zdobywaniu wiedzy, unikając poczucia dezorganizacji i przeciążenia.

Celem Studbota jest **wspieranie studentów** w efektywnym **zarządzaniu nauką** poprzez **analizę kart przedmiotów,** dostarczanie spersonalizowanych rekomendacji i ułatwienie przygotowania do zaliczeń.

#  3. Zakres systemu

Studbot to zaawansowany system oparty na sztucznej inteligencji, którego głównym celem jest wsparcie studentów w skutecznej organizacji nauki i lepszym zrozumieniu wymagań akademickich. Funkcjonuje on jako wirtualny asystent edukacyjny, który analizuje szczegółowo karty przedmiotów, by dostarczyć studentom kompleksowych informacji o ich kursach i obowiązkach.

### Analiza kart przedmiotów

Jednym z kluczowych zadań studbota jest dokładna analiza kart przedmiotów, które zawierają informacje o programie nauczania, wymaganiach i metodach zaliczania. Studbot wczytuje te dane, identyfikując kluczowe elementy, takie jak:

- **Cele przedmiotu**: Co student ma osiągnąć dzięki uczestnictwu w danym kursie.
- **Efekty kształcenia**: Jaką wiedzę, umiejętności i kompetencje społeczne student powinien nabyć.
- **Metody oceniania**: Jakie formy zaliczeń są przewidziane, np. egzaminy, kolokwia, projekty grupowe czy eseje.
- **Harmonogram zajęć i terminów zaliczeń**: Szczegółowe informacje o rozkładzie treści edukacyjnych i ważnych terminach.

Dzięki tej analizie studbot potrafi przedstawić studentowi przejrzysty obraz wymagań i zadań na każdym etapie kursu.

### Pomoc w organizacji nauki

Studbot odgrywa kluczową rolę w organizacji procesu nauki, dostosowując swoje rekomendacje do indywidualnych potrzeb użytkownika. Na podstawie analizy kart przedmiotów oraz informacji uzyskanych od studenta (np. jego poziomu wiedzy, preferencji nauki czy ilości czasu dostępnego na naukę), system tworzy spersonalizowane plany działania. W tym kontekście oferuje:

- **Priorytetyzację zadań**: Podkreśla, które zadania są najważniejsze lub najbardziej pilne.
- **Tworzenie harmonogramów**: Pomaga w układaniu planu nauki, dzieląc materiał na łatwe do przyswojenia fragmenty i proponując czas na powtórki.
- **Automatyczne przypomnienia**: Informuje o nadchodzących terminach zaliczeń czy istotnych wydarzeniach związanych z przedmiotami.

### Informacje o zaliczeniach

Studbot jest również cennym źródłem wiedzy na temat sposobu zaliczania przedmiotów. W przystępny sposób informuje studentów o tym, jak będą wyglądały egzaminy czy inne formy oceniania. Może np. wskazać, czy zaliczenie wymaga rozwiązania testu pisemnego, przygotowania projektu, czy może aktywności na zajęciach. Dzięki temu użytkownik dokładnie wie, czego się spodziewać i jak odpowiednio się przygotować.

### Cel i efekty kształcenia

Studbot nie tylko tłumaczy cele i efekty kształcenia, ale także pomaga studentowi zrealizować te założenia. System dostarcza materiały edukacyjne, sugeruje zasoby do nauki, takie jak książki, artykuły naukowe czy filmy edukacyjne, oraz proponuje dodatkowe ćwiczenia praktyczne. W ten sposób studbot pełni funkcję nie tylko doradcy, ale także przewodnika, który wspiera studenta na drodze do zdobycia wymaganej wiedzy.

### Personalizacja wsparcia

Jedną z największych zalet studbota jest jego zdolność do adaptacji. System potrafi dostosować swoje działania do zmieniających się potrzeb i preferencji studenta. Przykładowo, jeżeli student zgłasza trudności w zrozumieniu określonych zagadnień, studbot może zaproponować dodatkowe materiały edukacyjne lub zasugerować udział w konsultacjach z wykładowcą.

### Korzyści płynące z użytkowania studbota

Dzięki tak wszechstronnym funkcjom, studbot znacząco ułatwia życie studentom. Minimalizuje stres związany z organizacją nauki, pomaga w lepszym zarządzaniu czasem i zwiększa efektywność nauki. Jego rola jako interaktywnego i spersonalizowanego asystenta sprawia, że jest on idealnym rozwiązaniem w nowoczesnym środowisku akademickim, gdzie studenci muszą sprostać wielu wyzwaniom w krótkim czasie.

Podsumowując, studbot to narzędzie, które rewolucjonizuje proces edukacji, umożliwiając studentom bardziej efektywną naukę i lepsze przygotowanie do zaliczeń. Wykorzystując zaawansowaną technologię, staje się nieocenionym partnerem na drodze akademickiego sukcesu.

## Opis w formie User Stories 

  Jako student, chcę, aby studbot analizował karty przedmiotów, abym mógł szybko zrozumieć wymagania i cele każdego kursu.

  Jako student, chcę otrzymywać spersonalizowane plany nauki od studbota, aby efektywnie zarządzać swoim czasem i priorytetami.

  Jako student, chcę, aby studbot przypominał mi o ważnych terminach, takich jak egzaminy, kolokwia i oddanie projektów, abym zawsze był na bieżąco z harmonogramem.

  Jako student, chcę, aby studbot informował mnie o sposobach zaliczeń i rodzajach ocen, abym wiedział, jak się najlepiej przygotować.

  Jako student, chcę, aby studbot podpowiadał mi, jakie materiały edukacyjne lub dodatkowe zasoby są potrzebne do opanowania zagadnień, aby lepiej zrozumieć treści kursów.

  Jako student, chcę, aby studbot dostosowywał swoje rekomendacje do mojego poziomu wiedzy i preferencji nauki, abym mógł skuteczniej się uczyć.

  Jako student, chcę, aby studbot wyjaśniał mi trudne pojęcia lub tematy związane z kursem, aby szybciej rozwiewać wątpliwości i uzupełniać wiedzę.

  Jako student, chcę, aby studbot analizował mój postęp w nauce i proponował poprawki w planie działania, abym mógł osiągnąć lepsze wyniki w nauce.

# 4. Kontekst projektu

## 4.1. Wybór modelu

Podstawą do implementacji inteligentnego chatbota posiadającego szeroką wiedzę, potrzebną do realizacji projektu w warunkach akademickich jest wybranie odpowiedniego mnodelu spośród dostępnych LLM (Large Language Models). W tym celu wykonany został przegląd popularnych modeli.

1. **GPT-4 (OpenAI)**
   - **Zaleta**: Oferuje zaawansowaną zdolność rozumienia i generowania tekstu, z dużą elastycznością w wielu językach.
   - **Wada**: Wysokie koszty wdrożenia i konieczność posiadania dużej mocy obliczeniowej do pełnej integracji.
2. **LLaMA (Meta Platforms)**
   - **Zaleta**: Model open-source, co pozwala na łatwą modyfikację i dostosowanie do indywidualnych potrzeb.
   - **Wada**: Wymaga zaawansowanej wiedzy technicznej do konfiguracji i optymalizacji.
3. **PaLM 2 (Google)**
   - **Zaleta**: Wysoka jakość przetwarzania języka naturalnego, szczególnie w kontekście specjalistycznych dziedzin.
   - **Wada**: Ograniczona dostępność publiczna i zależność od infrastruktury Google.
4. **Claude (Anthropic)**
   - **Zaleta**: Zoptymalizowany pod kątem bezpieczeństwa i unikania szkodliwych odpowiedzi.
   - **Wada**: Mniejsza wydajność w porównaniu do większych modeli, takich jak GPT-4 i wysoki koszt implemetacji.
5. **Mistral**
   - **Zaleta**: Oferuje wysoką efektywność w kompaktowych wersjach modelu, co zmniejsza zapotrzebowanie na zasoby.
   - **Wada**: Brak pełnego wsparcia dla bardziej złożonych aplikacji w dużej skali.
6. **Cohere Command R**
   - **Zaleta**: Skupia się na generowaniu precyzyjnych odpowiedzi, idealnych do zadań związanych z dokumentacją i raportami.
   - **Wada**: Ograniczona możliwość generowania bardziej kreatywnych treści.
7. **Hugging Face Models (np. BLOOM, GPT-J)**
   - **Zaleta**: Bogata społeczność wspierająca i szeroki wybór modeli dostępnych open-source.
   - **Wada**: Niektóre modele mają niższą jakość generowanego tekstu i mniejszą bazę danych w porównaniu do komercyjnych alternatyw.
8. **Open Assistant**
   - **Zaleta**: Model open-source zaprojektowany z myślą o społecznościowym wkładzie i transparentności.
   - **Wada**: Ograniczona skala i funkcjonalność w porównaniu do większych modeli komercyjnych.
9. **Flan-T5 (Google)**
   - **Zaleta**: Wysoce wydajny w zadaniach wymagających przekazywania wiedzy z różnych źródeł.
   - **Wada**: Mniejsza zdolność do obsługi długich kontekstów w porównaniu do nowszych modeli.
10. **Megatron-Turing NLG (Microsoft NVIDIA)**

- **Zaleta**: Ogromna skala, umożliwiająca generowanie bardzo naturalnych odpowiedzi.
- **Wada**: Wysokie wymagania sprzętowe, które ograniczają dostępność dla mniejszych firm.

1. **Jurassic-2 (AI21 Labs)**

- **Zaleta**: Bardzo dobre przetwarzanie tekstu w języku angielskim z możliwością dostosowania do konkretnych zastosowań.
- **Wada**: Mniej zaawansowana obsługa wielojęzyczności w porównaniu do modeli takich jak GPT-4.

1. **Aleph Alpha**

- **Zaleta**: Wysoka efektywność w kontekstach wielojęzycznych i dostosowanie do wymagań europejskich użytkowników.
- **Wada**: Ograniczona społeczność użytkowników w porównaniu do bardziej popularnych modeli.



LLaMA jest doskonałym wyborem dla studentów, ponieważ jest modelem open-source, co pozwala na pełne dostosowanie jego działania do specyficznych potrzeb akademickich, takich jak analiza kart przedmiotów czy organizacja nauki. Dzięki swojej elastyczności i mniejszym wymaganiom sprzętowym w porównaniu do większych modeli komercyjnych, LLaMA oferuje wysoką wydajność nawet przy ograniczonych zasobach. Dodatkowo, dostępność społecznościowego wsparcia sprawia, że można łatwo rozwijać nowe funkcje i integracje.

Należy jednak pamiętać, że do wykorzystania LLaMA w aplikacjach komercyjnych lub instytucjonalnych **wymagane jest** **uzyskanie** odpowiedniej **zgody od Meta Platforms.** Złożyliśmy wniosek o udostępnienie nam modelu dla celów edukacyjnych i  **uzyskaliśmy zgodę** na jego wykorzystanie. Szczegóły umowy licencyjnej w pliku LICENSE AGREEMENT zamieszczonym na githib.

Spośród dostępnych wersji uznaliśmy za optymalny model **LLaMA3.2-3B-Instruct**. Jest od dobrym wyborem dla studentów pracujących nad projektem na własnych komputerach, ponieważ jest to stosunkowo lekki model, który zapewnia wysoką jakość przetwarzania języka naturalnego przy umiarkowanych wymaganiach sprzętowych. Dzięki swojej optymalizacji, model potrafi generować precyzyjne i użyteczne odpowiedzi bez konieczności korzystania z drogiej infrastruktury chmurowej. Dodatkowo, LLaMA3.2-3B-Instruct został zaprojektowany do efektywnej obsługi poleceń, co czyni go doskonałym narzędziem do takich zadań jak analiza dokumentów tekstowych czy organizacja nauki, kluczowych dla tego projektu.

## 4.2 Wybór języka programowania

Do tworzenia chatbota opartego o model LLM najlepiej nadają się języki programowania, które oferują silne wsparcie dla bibliotek sztucznej inteligencji oraz łatwość integracji z systemami przetwarzania danych. Najpopularniejszymi opcjami są Python, JavaScript (Node.js) oraz Go, ponieważ każdy z nich ma swoje unikalne zalety:

**Python**: Najlepszy wybór dzięki bogatej dostępności bibliotek i frameworków do pracy z modelami LLM (np. LangChain, Hugging Face Transformers, PyTorch, TensorFlow). Python jest intuicyjny w obsłudze i posiada szeroką społeczność, co ułatwia rozwiązywanie problemów oraz integrację różnych modułów.

**JavaScript (Node.js)**: Dobry wybór do aplikacji webowych w czasie rzeczywistym, z łatwą integracją z frontendem. Jednak ograniczenia w obsłudze dużych modeli i mniejsze wsparcie dla zaawansowanych bibliotek AI sprawiają, że jest mniej elastyczny.

**Go**: Wydajny język dla aplikacji o wysokiej wydajności, jednak wymaga więcej pracy, aby zaimplementować rozwiązania oparte o LLM, z mniejszym wsparciem dla dedykowanych bibliotek AI.

Na potrzeby projektu wybieramy język Python, ponieważ oferuje on najlepsze wsparcie dla bibliotek AI, które są kluczowe do uruchomienia i optymalizacji chatbota. Jego prostota w implementacji, szeroka dokumentacja oraz wsparcie społeczności pozwolą na szybkie i efektywne wdrożenie chatbota, nawet w warunkach akademickich i przy ograniczonych zasobach sprzętowych. Ponad to mamy doświadczenie w programowaniu w tym języku.

### Opis wykorzystanych frameworków i bibliotek 

1. **`os`**
   - **Opis**: Moduł standardowy w Pythonie, który umożliwia interakcję z systemem operacyjnym.
   - **Funkcje**: Pozwala na manipulację ścieżkami plików, odczytywanie i ustawianie zmiennych środowiskowych, a także operacje na systemie plików.
   - **Przykład zastosowania**: Zarządzanie kluczami API lub plikami konfiguracyjnymi w środowisku lokalnym.
2. **`logging`**
   - **Opis**: Moduł do zarządzania logami w aplikacji.
   - **Funkcje**: Umożliwia rejestrowanie zdarzeń (logów) na różnych poziomach szczegółowości, takich jak debug, info, warning, error i critical.
   - **Przykład zastosowania**: Śledzenie działania aplikacji i debugowanie błędów.
3. **`json`**
   - **Opis**: Moduł standardowy do pracy z danymi w formacie JSON (JavaScript Object Notation).
   - **Funkcje**: Umożliwia serializację (konwersję obiektów Python do JSON) i deserializację (odczyt JSON jako obiektów Python).
   - **Przykład zastosowania**: Wymiana danych między aplikacją a API w formacie JSON.
4. **`dotenv` (funkcja `load_dotenv`)**
   - **Opis**: Biblioteka, która umożliwia łatwe ładowanie zmiennych środowiskowych z pliku `.env`.
   - **Funkcje**: Pozwala przechowywać klucze API, hasła lub inne poufne dane w bezpieczny sposób poza kodem źródłowym.
   - **Przykład zastosowania**: Automatyczne wczytanie klucza API potrzebnego do połączenia z Pinecone lub innym serwisem.
5. **`langchain.chains.RetrievalQA`**
   - **Opis**: Moduł LangChain umożliwiający budowę systemów QA (Questions and Answers) opartych na odzyskiwaniu informacji z zewnętrznego źródła, np. bazy danych.
   - **Funkcje**: Kombinuje system odzyskiwania danych (np. wyszukiwania wektorowego) z modelem LLM, aby generować odpowiedzi na pytania.
   - **Przykład zastosowania**: Tworzenie chatbotów, które odpowiadają na pytania na podstawie dedykowanej bazy wiedzy.
6. **`langchain_pinecone.PineconeVectorStore`**
   - **Opis**: Integracja LangChain z Pinecone, usługą do przechowywania i wyszukiwania wektorów.
   - **Funkcje**: Umożliwia efektywne przechowywanie i przeszukiwanie reprezentacji wektorowych danych (np. dokumentów).
   - **Przykład zastosowania**: Wyszukiwanie informacji w dużych zbiorach danych na podstawie podobieństwa wektorowego.
7. **`langchain_ollama.OllamaEmbeddings`**
   - **Opis**: Moduł odpowiedzialny za generowanie reprezentacji wektorowych (embeddingów) dla tekstów przy użyciu modelu Ollama.
   - **Funkcje**: Przekształca dane tekstowe w reprezentacje numeryczne, które są używane w wyszukiwaniu podobieństw.
   - **Przykład zastosowania**: Tworzenie bazy wektorowej do przetwarzania pytań i odpowiedzi.
8. **`langchain_ollama.OllamaLLM`**
   - **Opis**: Integracja LangChain z modelem językowym Ollama, który może być używany do generowania tekstów i odpowiedzi.
   - **Funkcje**: Wykorzystuje model LLM do generowania kontekstowych odpowiedzi na podstawie danych wejściowych.
   - **Przykład zastosowania**: Tworzenie chatbota, który odpowiada na pytania użytkownika w naturalny sposób.
9. **`langchain.callbacks.manager.CallbackManager`**
   - **Opis**: Moduł zarządzający callbackami, które umożliwiają monitorowanie i interakcję z różnymi etapami działania aplikacji.
   - **Funkcje**: Pozwala na rejestrowanie i uruchamianie funkcji zwrotnych w trakcie działania procesu.
   - **Przykład zastosowania**: Monitorowanie postępu przetwarzania danych w modelu LLM.
10. **`langchain.callbacks.streaming_stdout.StreamingStdOutCallbackHandler`**
    - **Opis**: Handler obsługujący strumieniowe wyświetlanie wyników w konsoli (stdout).
    - **Funkcje**: Pozwala na obserwację generowania odpowiedzi w czasie rzeczywistym.
    - **Przykład zastosowania**: Wyświetlanie odpowiedzi modelu na bieżąco podczas rozmowy z chatbotem.
11. **`langchain.schema.runnable.RunnablePassthrough`**
    - **Opis**: Moduł przekazujący dane wejściowe bezpośrednio jako dane wyjściowe bez żadnych modyfikacji.
    - **Funkcje**: Przydatny do debugowania lub łączenia komponentów w bardziej złożonych przepływach danych.
    - **Przykład zastosowania**: Przekazywanie danych między różnymi etapami w ramach aplikacji LangChain.
12. **`langchain.schema.output_parser.StrOutputParser`**
    - **Opis**: Parser odpowiedzialny za przetwarzanie wyjść z modeli LLM jako ciągów znaków (string).
    - **Funkcje**: Umożliwia konwersję odpowiedzi generowanych przez model do formatu tekstowego, który może być dalej przetwarzany.
    - **Przykład zastosowania**: Przetwarzanie odpowiedzi modelu w celu dalszej analizy lub wyświetlania użytkownikowi.
13. **`langchain_core.prompts.PromptTemplate`**
    - **Opis**: Narzędzie do definiowania i zarządzania szablonami promptów używanych przez modele LLM.
    - **Funkcje**: Pozwala na dynamiczne generowanie promptów na podstawie zmiennych wejściowych.
    - **Przykład zastosowania**: Tworzenie spersonalizowanych zapytań dla chatbota, dostosowanych do kontekstu rozmowy.



## 4.3 Personalizacja chatbota

**Fine-tuning** to proces dostosowywania wcześniej wytrenowanego modelu językowego LLM do konkretnych zadań lub domen poprzez dalsze trenowanie go na specyficznym zbiorze danych. W praktyce oznacza to, że model, który już potrafi rozumieć i generować tekst, jest dodatkowo szkolony na danych zawierających wiedzę lub zadania specyficzne dla danego zastosowania, np. język prawniczy, medyczny czy pytania związane z określoną branżą. Proces szkolenia modelu mógłby dać dobre efekty jednak wymagałby stworzenia obszernej bazy danych. Ponad to wykorzystanie możliwości finte-tunigu modelu wiąże się z kosztami. 

**Baza wektorowa** to narzędzie, które umożliwia przechowywanie i wyszukiwanie danych w postaci wektorów reprezentujących semantykę tekstu. W kontekście chatbota opartego na modelu językowym (LLM), baza wektorowa pozwala na dostarczanie precyzyjnych i kontekstowych odpowiedzi bez konieczności pełnego trenowania modelu na każdym nowym zbiorze danych. Pozwala to na dostarczenie precyzyjnych danych do wykorzystania przez model niskim kosztem. W dodatku operacja taka nie wymaga tworzenia obszernej bazy potrzebnej do trenowania modelu. Wadą tego rozwiązania jest znaczne zwiększenie ilości tokenów wykorzystywanych w promcie wjeściowym, oraz w historii konwersacji. Jest to jednak najlepsze rozwiązanie

 Na potrzeby projektu, dla sprawdzenia działania chatbota wystarczającym jest wykorzystanie jednej karty przedmiotu. Użyta została karta przedmiotu dla przedmiotu Inżynieria Oprogramowania, która została przetworzona na bazę wektorową opartą o 384 wymiary. 

## 5. Scenariusze testowe

Jako student chcę, aby Studbot analizował karty przedmiotów, abym mógł szybko zrozumieć cele każdego kursu.

**Scenariusz testowy**:

Chatbot zostaje zapytany o cel przedmiotu

**Oczekiwany wynik**:

 Chatbot wyodrębnia z karty cele przedmiotu.

**Kryterium sukcesu**: 

Informacje są poprawnie wyodrębnione i zaprezentowane w zrozumiałej formie.

**Test:**

**Input**: What are the objectives of the 'Software Engineering' course, and what benefits will I gain by completing it?

**Output**: 

The objectives of the 'Software Engineering' course (PG_00136700) can be found in the provided document under 'Subject Objectives': 

\- Familiarizing students with the basic problems, methods, techniques, and tools of software engineering.

\- Preparing students to create useful, high-quality software for private needs and enterprises, public, and non-profit sector institutions.

By completing this course, you will gain:

\- Familiarity with the fundamental concepts of software engineering

\- Ability to plan, design, and program information systems to support economic entities (IiEL3_U04)

\- Understanding of ethical norms, business practices, and intellectual property regulations (IiEL3_W07)

\- Knowledge of methods for obtaining, processing, and analyzing economic data (IiEL3_W04)

\- Team management skills and effective communication of computer science and econometrics topics (IiEL3_K03 and IiEL3_K02)

------

**Scenariusz testowy**:

Chatbot zostaje zapytany o literaturę przedmiotu

**Oczekiwany wynik**:

 Chatbot wyodrębnia z karty literaturę przedmiotu i przedstawia ją w odpowiedzi.

**Kryterium sukcesu**: 

Informacje są poprawnie wyodrębnione i zaprezentowane w zrozumiałej formie.

**Test:**

**Input**: Which literature should I read to pass the software engineering course?

**Output**: To pass the software engineering course, you need to achieve a passing threshold of 60% on the exam, which accounts for 100% of your final grade.

 

The recommended reading includes:

\- **Basic Literature**:

 \- Pressman R.S., *Software Engineering: A Practitioner's Approach*, McGraw-Hill, 2005.

 \- Sommerville I., *Software Engineering*, Addison Wesley, 2004.

 \- S. Wrycza, J. MaÅ›lankowski, *Informatyka ekonomiczna. Teoria i zastosowania*, PWN, Warszawa 2019.

\- **Supplementary Literature**:

 You can refer to the supplementary literature for additional insights and understanding of software engineering concepts.

Please note that while these literature sources are recommended, they might not be sufficient on their own to guarantee a passing grade. It's also important to attend classes, participate in discussions, and complete assigned tasks and projects as per the course schedule.

If you have any further questions or need clarification on specific topics, feel free to ask!

------

**Scenariusz testowy**:

Chatbot zostaje zapytany o to jakiego typu tematy porusza kurs.

**Oczekiwany wynik**:

 Chatbot wyjaśnia jakie teamty są poruszane na zajęciach.

**Kryterium sukcesu**: 

Informacje są poprawnie wyodrębnione i zaprezentowane w zrozumiałej formie.

**Test:**

\- **IS and Software Design**: This topic includes:

 \- System life cycle models

 \- Cost estimation

 \- Project scheduling

 \- Reliability issues

\- **Intellectual Property Rights**: This topic focuses on protection and management of intellectual property rights in IT projects.

These topics are part of the subject contents of the course, which can be found in Document(id='23279b45-085b-4621-80c2-dafd4376e6e6').

------

**Scenariusz testowy**:

Chatbot zostaje zapytany o to jakie umiejętności zdobędzie poprzez udział w danym kursie, a zapytany o konkretną umiejętność jest w stanice wskazać czy została ona wymieniona w karcie przedmiotu.

**Oczekiwany wynik**:

 Chatbot wyjaśnia jakie umiejętności student może uzyskać dzięki uczestnistwu w kursie i odpowida na pytanie o konkretną umiejętność.

**Kryterium sukcesu**: 

Informacje są poprawnie wyodrębnione i zaprezentowane w zrozumiałej formie.

**Test:**

**Input**: What skills will I acquire after completing this course? Does it include knowledge about IT project management?

**Output**: After completing this Software Engineering course, you can expect to acquire skills in planning, designing, and programming information systems, as well as understanding the need for supplementation and deepening of knowledge. Additionally, you will gain advanced knowledge of ethical norms, business practices, intellectual property regulations, methods for obtaining, processing, and analyzing economic data, teamwork, and communication of computer science and econometrics topics.

Regarding IT project management, while the course doesn't explicitly focus on it as a separate subject, it covers aspects that can be considered related to project management, such as:

\*  Planning, design, and programming information systems

\*  Cost estimation

\*  Project scheduling

\*  Reliability issues

These topics are essential for understanding how to manage projects in the software engineering field. However, if you're looking for a course specifically focused on IT project management, you may want to consider additional resources or courses that delve into this area.

------

